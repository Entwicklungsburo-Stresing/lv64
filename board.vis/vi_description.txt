Description of Labview sub vis

!!!!
Befor calling any sub VIs, Init-> InitDrv + InitBrd  must have been called, 
When ending the exit should be called also.
otherwise an Errormessage appears! 
Wrap your call as shown in abouttest.vi


** general message box suppress ** 
by default the DLL sends message boxes on error
if this is not wanted, it can be suppressed by calling: DLLErrMsgBoxOff

ErrMsgOn.vi			// if msg was turned off, it can be turned on gain by calling this func
void DLLErrMsgBoxOn(void);	// BOARD.C sends error messages on default
ErrMsgOff.vi
void DLLErrMsgBoxOff(void);	//general deactivate of error message boxes



******  List of functions  ***********

about.vi
DLLdef.: void  DLLAboutDrv(uint32_t arg1);
function: return infos about the PCI board, shows 5 info messages
	can be used to test the communication with the PCI board
input: board number (=1 if one PCI board)
output: none
win1 : version of driver 
win2 : ID =53xx
win3 : length of space0 BAR =0x3f
win4 : vendor ID = EBST
win5 : PCI board version

Cal16Bit.vi
DLLdef.: void  DLLCal16Bit(uint32_t drv, uint32_t zadr);
function: starts calibrate cycle for older ADC16061 converter,
not needed for actual 16 bit version
input1: board number (=1 if one PCI board)
input2: zadr = 1, not needed, only if in addressed mode
output: none

clearRead.vi
DLLdef.: void  DLLClrRead(uint32_t drvno, uint32_t fftlines, uint32_t zadr, uint32_t CCDClrCount);
function: needed to erase all charges after a long pause and overexposure
reads camera clrcount times and don't keep data.
input1: board number (=1 if one PCI board)
input2: fftlines =0 for most sensors, = number of lines for binning if FFT sensor
input3: zadr = 1, not needed, only if in addressed mode
input4: clrcount : number of reads, depends on sensor
output: none

closeshutter.vi
DLLdef.: void  DLLCloseShutter(uint32_t arg1);
function: sets the IFC Bit of Interface for sensors with shutter function
input1: board number (=1 if one PCI board)
output: none

Coolon.vi
DLLdef.: void  DLLActCooling(uint32_t drv, uint8_t on);
function: activates cooling for cooled cameras
input1: board number (=1 if one PCI board)
input2: on (=1 = true)
output: none

Exit.vi
DLLdef.: void  DLLCCDDrvExit(uint32_t drv);
function: frees handle and memory -> exit driver
input1: board number (=1 if one PCI board)
output: none

FFDis.vi
DLLdef.: void  DLLDisableFifo(uint32_t drv);
function: disable FIFO
input1: board number (=1 if one PCI board)
output: none

FFEn.vi
DLLdef.: void  DLLEnableFifo(uint32_t drv);
function: enable FIFO
input1: board number (=1 if one PCI board)
output: none

FFGETone.vi
DLLdef.: void  DLLPickOneFifoscan(uint32_t drv, uint16_t *pdioden, uint8_t *abbr, uint8_t *space, int32_t fkt);
function: special read sequence for FIFO version only
	fifo timer is running and Fifo is enabled for one read
	data is written to array, Fifo is disabled again
input1: board number (=1 if one PCI board)
input2: pdioden = pointer to data array
input3: abbr = address of bool var, is true (not 0) if ESC was hit
input4: space = address of bool var, is true (not 0) if Space was hit
input5: fkt = 1 for standard read, others are possible -> C source
output: none

FFOvl.vi
DLLdef.: uint8_t DLLFFOvl(uint32_t drv);
function: check ovl flag (overflow of FIFO)
	if occured stays active until a call of FFRS
input1: board number (=1 if one PCI board)
output: is true (not 0)if overflow occured

FFRead.vi
DLLdef.: void  DLLReadFifo(uint32_t drv, uint16_t *dioden, int32_t fkt);
function: read one line from FIFO (be sure that FFValid is true before calling)
	simplest way to get data 
input1: board number (=1 if one PCI board)
input2: pdioden = pointer to data array
input3: fkt = 1 for standard read, others are possible -> C source
output: none

FFReadCnt.vi
DLLdef.: uint8_t DLLReadFFCounter(uint32_t drv);
function: reads the line counter (how many lines are in the FIFO)
input1: board number (=1 if one PCI board)
output: number of lines

FFRS.vi
DLLdef.: void  DLLRSFifo(uint32_t drv);
function: reset FIFO
input1: board number (=1 if one PCI board)
output: none

FFStopTimer.vi
DLLdef.: void  DLLStopFFTimer(uint32_t drv);
function: stop timer (stop camera read)
input1: board number (=1 if one PCI board)
output: none

FFSWTrig.vi
DLLdef.: void  DLLSWTrig(uint32_t drv);
function: triggers one camera read by calling this function
input1: board number (=1 if one PCI board)
output: none

FFValid.vi
DLLdef.: uint8_t DLLFFValid(uint32_t drv);
function: checks content of FIFO
input1: board number (=1 if one PCI board)
output: is true (not 0) if FIFO keeps >= 1 complete lines 

FFXCKI.vi
DLLdef.: uint8_t DLLFlagXCKI(uint32_t drv);
function: is high if camera read is active
input1: board number (=1 if one PCI board)
output: is true (not 0) if read is currently active 

GETCCD.vi
DLLdef.: void  DLLGETCCD(uint32_t drv, uint32_t *dioden, uint32_t fftlines, int32_t fkt, uint32_t zadr);
function: read camera for NO FIFO version only
	each call reads camera and distance to next read defines exposure time
input1: board number (=1 if one PCI board)
input2: pdioden = pointer to data array
input3: fftlines =0 for most sensors, = number of lines for binning if FFT sensor
input4: fkt = 1 for standard read, others are possible -> C source
input5: zadr = 1, not needed, only if in addressed mode

HiSlope.vi
DLLdef.: void  DLLHighSlope(uint32_t drv);
function: set the external trigger slope to + (PCI Reg CrtlA:D5 -> manual)
input1: board number (=1 if one PCI board)
output: none

InitBrd.vi
DLLdef.: void  DLLInitBoard(uint32_t drv, uint8_t sym, uint8_t burst, uint32_t pixel, uint32_t waits, uint32_t flag816, uint32_t pportadr, uint32_t pclk, uint32_t xckdelay);
function: initialize the PCI board, must be called once at the start
input1: board number (=1 if one PCI board)
input2: sym = 0 for FIFO, depends on sensor if NO FIFO
input3: burst = 1 for FIFO, depends on sensor if NO FIFO
input4: pixel = number of all pixel (active + dummy pixel)
input5: waits = depends on sensor, sets the pixel read frequency 
input6: flag816 =1 if AD resolution 12 to 16 bit, =2 if 8bit 
input7: pportadr =0 address if parallel port is used
input8: pclk =0 pixelclock, not used here
input9: xckdelay =3, depends on sensor, sets a delay after xck goes high, =7 for Sony sensors
output: none

InitDrv.vi
DLLdef.: uint8_t DLLCCDDrvInit(uint32_t drv);
function: initialize the driver, must be called before any other
input1: board number (=1 if one PCI board)
output: is true (not 0) if driver was found

InitSysTimer.vi
DLLdef.: void  DLLInitSysTimer(void );
function: only NO FIFO version: initialize the systems high res timer for exact timing
input1: none
output: none

IsFFT.vi
DLLdef.: void  DLLSetISFFT(uint32_t drv, uint8_t set);
function: set/reset bit for FFT sensor timing(set Reg TOR:D24 -> manual)
input1: board number (=1 if one PCI board)
input2: if set is true (not 0)-> bit is set, reset else
output: none

IsPDA.vi
DLLdef.: void  DLLSetISPDA(uint32_t drv, uint8_t set);
function: set/reset bit for PDA sensor timing(set Reg TOR:D25 -> manual)
input1: board number (=1 if one PCI board)
input2: if set is true (not 0)-> bit is set, reset else
output: none

LowSlope.vi
DLLdef.: void  DLLLowSlope(uint32_t drv);
function: set the external trigger slope to - (PCI Reg CrtlA:D5 -> manual)
input1: board number (=1 if one PCI board)
output: none

Mouse_off.vi
DLLdef.: void  DLLDeactMouse(uint32_t drv);
function: deactivate mouse (should only be used for single core systems)
input1: board number (=1 if one PCI board)
output: none

Mouse_on.vi
DLLdef.: void  DLLActMouse(uint32_t drv);
function: activate mouse (should only be used for single core systems)
input1: board number (=1 if one PCI board)
output: none

OpenShutter.vi
DLLdef.: void  DLLOpenShutter(uint32_t drv);
function: open shutter for sensors with EC (exposure control) / sets IFC signal, if not set the shutter is triggert by EC Ctrl
input1: board number (=1 if one PCI board)
output: none

OTrig_h.vi
DLLdef.: void  DLLOutTrigHigh(uint32_t drv);
function: set trigger out(Reg CtrlA:D3) of PCI board. Can be used to control timing issues in software.
	The Reg TOR:D31 must have been set to 1 and D30:D27 to zero to see the signal -> see manual
input1: board number (=1 if one PCI board)
output: none

OTrig_l.vi
DLLdef.: void  DLLOutTrigLow(uint32_t drv);
function: reset trigger out(Reg CtrlA:D3) of PCI board. Can be used to control timing issues in software.
	The Reg TOR:D31 must have been set to 1 and D30:D27 to zero to see the signal -> see manual
input1: board number (=1 if one PCI board)
output: none

OutTrigP.vi
DLLdef.: void  DLLOutTrigPulse(uint32_t drv, uint32_t PulseWidth);
function: pulses trigger out(Reg CtrlA:D3) of PCI board. Can be used to control timing issues in software.
	The Reg TOR:D31 must have been set to 1 and D30:D27 to zero to see the signal -> see manual
input1: board number (=1 if one PCI board)
input2: duration of pulse in ms
output: none

ReadB.vi
DLLdef.: uint8_t DLLReadByteS0(uint32_t drv, uint32_t PortOff);
function: read byte (8 bit) from register in space0 of PCI board
input1: board number (=1 if one PCI board)
input2: PortOff of register (count in bytes)
output: byte value of register

ReadFFLoop.vi
DLLdef.: void  DLLReadFFLoop(uint32_t drv, uint32_t *dioden, uint32_t fftlines, int32_t fkt, uint32_t zadr, uint32_t nos,
 uint32_t exptus, uint32_t freq, uint32_t threadp, uint32_t clrcnt, int16_t releasems, uint32_t exttrig, uint32_t blocktrigger);
function: only for FIFO version: block read of nos scans 
input1: board number (=1 if one PCI board)
input2: pdioden = pointer to data array
input3: fftlines =0 for most sensors, = number of lines for binning if FFT sensor
input4: fkt = 1 for standard read, others are possible -> C source
input5: zadr = 1, not needed, only if in addressed mode
input6: nos = number of scans
input7: exptus = exposure time in micro sec. If this entry is used, freq must be set to 0
input8: freq = read frequency in Hz. If this entry is used, exptus must be set to 0
input9: threadp = 31, priority of thread (1..31/ 31 is highest -> see manual)
input10: clrcnt = number of reads to clear the sensor before block starts, depends on sensor
input11: releasems = -1, time to release thread in ms (for long exposuretimes), <0 means don't release
input12: exttrig = true (not 0) if external trigger for each scan, 0 else
input13: blocktrigger = true (not 0) if one external trigger starts block of nos scans which run with internal timer
output: none

ReadL.vi
DLLdef.: uint32_t DLLReadLongS0(uint32_t drv, uint32_t PortOff);
function: read long (32 bit) from register in space0 of PCI board
input1: board number (=1 if one PCI board)
input2: PortOff of register (count in bytes)
output: long value of register

ReadLoop.vi
DLLdef.: void  DLLReadLoop(uint32_t drv, uint32_t *dioden, uint32_t fftlines, int32_t fkt, uint32_t zadr, uint32_t nos, 
	uint32_t exptus, uint32_t freq, uint32_t threadp, uint32_t clrcnt, uint32_t exttrig);
function: only for NO FIFO version: block read of nos scans 
input1: board number (=1 if one PCI board)
input2: pdioden = pointer to data array
input3: fftlines =0 for most sensors, = number of lines for binning if FFT sensor
input4: fkt = 1 for standard read, others are possible -> C source
input5: zadr = 1, not needed, only if in addressed mode
input6: nos = number of scans
input7: exptus = exposure time in micro sec. If this entry is used, freq must be set to 0
input8: freq = read frequency in Hz. If this entry is used, exptus must be set to 0
input9: threadp = 31, priority of thread (1..31/ 31 is highest -> see manual)
input10: clrcnt = number of reads to clear the sensor before block starts, depends on sensor
input11: releasems = -1, time to release thread in ms (for long exposuretimes), <0 means don't release
input12: exttrig = true (not 0) if external trigger for each scan, 0 else
input13: blocktrigger = true (not 0) if one external trigger starts block of nos scans which run with internal timer
output: none

RS_TOREG.vi
DLLdef.: void  DLLRsTOREG(uint32_t drv);
function: reset TOR register
input1: board number (=1 if one PCI board)
output: none

SetAd16Default.vi
DLLdef.: void  DLLSetAD16Default(uint32_t drv, uint32_t res);
function: set AD9826 (cds converter: ILC6) to default values (set fixed in BOARD.C)
input1: board number (=1 if one PCI board)
input2: res =1 is the resolution 16bit
output: none

SetAdGain.vi
DLLdef.: void  DLLSetADAmpRed(uint32_t drv, uint8_t gain);
function: set internal register for amplification of AD9826 (cds converter for sensor ILC6)
	full scale of A/D must be adjusted to full scale of signal 
input1: board number (=1 if one PCI board)
input2: gain 0..64
output: none

SetAdOff.vi
DLLdef.: void  DLLSetADOff(uint32_t drv, uint8_t ofs, uint8_t pos);
function: set internal register for offset of AD9826 (cds converter for sensor ILC6)
	zero line can be set here 
input1: board number (=1 if one PCI board)
input2: ofs = value 0..255
input3: pos = offset can be positive or negative, is positive if not 0 
output: none

SetDA.vi
DLLdef.: void  DLLSetDA(uint32_t drv, uint8_t gain, uint8_t ch);
function: set DA converter gain value for EM (electron multipliying) sensor TC253
input1: board number (=1 if one PCI board)
input2: gain = value 0..255 set the multiplying factor
input3: ch = 1  
output: none

SetExtTrig.vi
DLLdef.: void  DLLSetExtTrig(uint32_t drv);
function: set trigger to extern, if extern trigger should be stopped, switch to internal and stop timer
input1: board number (=1 if one PCI board)
output: none

SetIntTrig.vi
DLLdef.: void  DLLSetIntTrig(uint32_t drv);
function: set trigger to intern
input1: board number (=1 if one PCI board)
output: none

SetOvsmp.vi
DLLdef.: void  DLLSetOvsmpl(uint32_t drv, int32_t zadr);
function: set oversample function - only available for special sensors
input1: board number (=1 if one PCI board)
input2: zadr = 1, not needed, only if in addressed mode
output: none

SetTemp.vi
DLLdef.: void  DLLSetTemp(uint32_t drv, uint32_t level);
function: set temperature level for cooled cameras
input1: board number (=1 if one PCI board)
input2: level 0..7 / 0=off, 7=min -> see cooling manual
output: none

SetTOREG.vi
DLLdef.: void  DLLRsTOREG(uint32_t drv);
function: set TOR register (maps signal to output BNC plug of PCI board
input1: board number (=1 if one PCI board)
input2: fkt 0..5, (0=XCK, 1=outrighigh/low, 2=FiFoRead, 3=(frame of IRArea), 4=EC, 5=DAT
output: none

SetVCLKReg.vi
DLLdef.: void  DLLSetupVCLK(uint32_t drv, uint32_t lines, uint8_t vfreq);
function: set REG VCLKCTRL for FFT sensors
input1: board number (=1 if one PCI board)
input2: number of vertical lines
input3: vertical clk frequency
output: none

SRingBlockTrig.vi
DLLdef.: UINT8 DLLRingBlockTrig(UCHAR ch);
function: reads the binary state of an ext. trigger input
input1: ch=0: PCI in, ch=2: opto1, ch=3: opto2


SRingLastRead.vi
DLLdef.: void  DLLFetchLastRingLine(uint16_t *dioden);
function: get last scan of ring puffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: pdioden = pointer to data array
output: none

SRingReadCnt.vi
DLLdef.: uint8_t DLLReadRingCounter(uint32_t drv);
function: get act counter value of ring buffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1:  board number (=1 if one PCI board)
output: counter value

SRingStartFetch.vi
DLLdef.: void  DLLStartFetchRingBuf(void );
function: start thread to copy data from ring buffer to display buffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: none
output: none

SRingStartThread.vi
DLLdef.: void  DLLStartRingReadThread(uint32_t drv, uint32_t ringdepth, uint32_t threadp, int16_t releasems);
function: get act counter value of ring buffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: board number (=1 if one PCI board)
input2: ringdepth = size of ring buffer
input3: threadp = 31, priority of thread (1..31/ 31 is highest -> see manual)
input4: releasems = -1, time to release thread in ms (for long exposuretimes), <0 means don't release
output: none

SRingStopThread.vi
DLLdef.: void  DLLStopRingReadThread(void );
function: stop thread to copy data from ring buffer to display buffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: none
output: none

SRingThreadIsOFF.vi
DLLdef.: uint8_t DLLRingThreadIsOFF(void );
function: check if thread is still running, used for sync threads
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: none
output: is true (not 0) if thread was stopped

SRingValid.vi
DLLdef.: uint8_t DLLRingValid(uint32_t drv);
function: check if counter value is > 0 of ring buffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: board number (=1 if one PCI board)

StartTimer.vi
DLLdef.: void  DLLStartTimer(uint32_t drv, uint32_t exptime);
function: start hardware timer
input1: board number (=1 if one PCI board)
input2: exposure time in micro sec
output: none

TGood.vi
DLLdef.: uint8_t DLLTempGood(uint32_t drv, uint32_t ch);
function: check status of cooling (temperature good = state of EOI signal)
input1: board number (=1 if one PCI board)
input2: ch=1 for first camera, =2 for 2nd and so on
output: is true (not 0) if temperature is reached and stable

V_off.vi
DLLdef.: void  DLLVOff(uint32_t drv);
function: set amplification to low (IR sensors have switchable amp.), reset VON signal
input1: board number (=1 if one PCI board)
output: none

V_on.vi
DLLdef.: void  DLLVOn(uint32_t drv);
function: set amplification to high (IR sensors have switchable amp.), set VON signal
input1: board number (=1 if one PCI board)
output: none

WaitforTelapsed.vi
DLLdef.: uint8_t DLLWaitforTelapsed(uint32_t musec);
function: used to get a constant delay, for NO FIFO hires timer 
input1: board number (=1 if one PCI board)
output: is true (not 0) if time elapsed

WaitTrig.vi
DLLdef.: void  DLLWaitTrigger(uint32_t drv, uint8_t ExtTrig, uint8_t *SpaceKey, uint8_t *EscapeKey);
function: wait for trigger (on PCI boards input) or key 
	waittrigger is used for NO FIFO version, key test can always be used 
input1: board number (=1 if one PCI board)
input2: ExtTrig = set true (not 0) for extern trigger, false for internal - then its be used for key test
input3: space = address of bool var, is true (not 0) if Space was hit
input4: abbr = address of bool var, is true (not 0) if ESC was hit
output: none

WriteB.vi
DLLdef.: void  DLLWriteByteS0(uint32_t drv, uint8_t DataByte, uint32_t PortOff);
function: write byte (8 bit) to register in space0 of PCI board
input1: board number (=1 if one PCI board)
input2: DataByte = byte value to write
input3: PortOff of register (count in bytes)
output: none

WriteL.vi
DLLdef.: void  DLLWriteLongS0(uint32_t drv, uint32_t DataByte, uint32_t PortOff);
function: write long (32 bit) to register in space0 of PCI board
input1: board number (=1 if one PCI board)
input2: DataByte = long value to write
input3: PortOff of register (count in bytes)
output: none


